import io
import streamlit as st
from datetime import datetime

# import calculation helpers from tools.calc
from tools.calc import (
    SECTOR_DATA,
    DR_STRATEGIES,
    CONTROL_COSTS,
    compute_sle,
    compute_ale_pre,
    compute_ale_post,
    compute_downtime_loss,
    compute_expected_annual_breach_cost,
    compute_rosi,
    generate_pdf,
    generate_pdf_bytes,
)

st.set_page_config(page_title="Risk & BCDR Prototype", layout="wide")

st.sidebar.title("Inputs")
sector = st.sidebar.selectbox("Sector", options=list(SECTOR_DATA.keys()), index=2)
asset = st.sidebar.number_input("Asset / Revenue (USD)", min_value=0.0, value=100000.0, step=1000.0, format="%.2f")
ef = st.sidebar.slider("Exposure Factor (EF %)", min_value=0, max_value=100, value=100)

strategy = st.sidebar.radio("BCDR Strategy", options=list(DR_STRATEGIES.keys()), index=0)

st.sidebar.markdown("---")
st.sidebar.write("Controls")
col1, col2 = st.sidebar.columns(2)
with col1:
    mfa = st.checkbox("Enable MFA", value=False)
    phish = st.checkbox("Phishing training", value=False)
with col2:
    succession = st.checkbox("Succession planning", value=False)

include_dr_cost = st.sidebar.checkbox("Include DR annual cost in ROSI", value=True)

st.title("Small Business Reality Check — Prototype")

# compute numbers
loss_magnitude = SECTOR_DATA[sector].get('AvgBreachCost', asset)

ale_pre = compute_ale_pre(sector, loss_magnitude, ef)
ale_post = compute_ale_post(sector, loss_magnitude, ef, mfa=mfa, phish=phish)

downtime_cold = compute_downtime_loss(sector, 'Cold Site', succession=False)
downtime_selected = compute_downtime_loss(sector, strategy, succession=succession)
money_saved = max(0, downtime_cold - downtime_selected)

# cost of controls
cost_controls = DR_STRATEGIES.get(strategy, {}).get('annual_cost', 0)
if mfa:
    cost_controls += CONTROL_COSTS.get('mfa', 0)
if phish:
    cost_controls += CONTROL_COSTS.get('phish', 0)
if succession:
    cost_controls += CONTROL_COSTS.get('succession', 0)

# optionally exclude DR cost from ROSI calculation
rosi_cost_basis = cost_controls if include_dr_cost else (cost_controls - DR_STRATEGIES.get(strategy, {}).get('annual_cost', 0))
rosi = compute_rosi(ale_pre, ale_post, money_saved, rosi_cost_basis)

# Display main metrics
col_a, col_b, col_c = st.columns([1, 1, 1])
with col_a:
    st.metric(label="ALE (pre-controls)", value=f"${ale_pre:,.0f}")
with col_b:
    st.metric(label="ALE (post-controls)", value=f"${ale_post:,.0f}")
with col_c:
    rosi_display = "inf" if rosi == float('inf') else f"{rosi*100:.1f}%"
    st.markdown(f"**ROSI:** <span style='color: #0a8a0a; font-weight:700'>{rosi_display}</span>", unsafe_allow_html=True)

st.markdown(f"**Money saved by BCDR:** <span style='color:#0a8a0a; font-size:20px; font-weight:700'>${money_saved:,.0f}</span>", unsafe_allow_html=True)

# Bar chart (Inherent vs Residual ALE)
import pandas as pd
chart_df = pd.DataFrame({
    'Value': [ale_pre, ale_post]
}, index=['ALE Pre', 'ALE Post'])

st.subheader('Inherent vs Residual ALE')
st.bar_chart(chart_df)

st.markdown('---')

st.header('Generate PDF Report')
if st.button('Create & Download PDF'):
    # build report_data similar to CLI
    report_data = {
        'title': 'Small Business Reality Check — Report',
        'sector': sector,
        'asset': asset,
        'ef': ef,
        'aro': SECTOR_DATA[sector].get('ARO'),
        'sle': compute_sle(asset, ef),
        'ale_pre': ale_pre,
        'ale_post': ale_post,
        'expected_breach': compute_expected_annual_breach_cost(SECTOR_DATA[sector].get('AvgBreachCost', 0), SECTOR_DATA[sector].get('ARO')),
        'downtime_cold': downtime_cold,
        'downtime_selected': downtime_selected,
        'money_saved_by_bcdr': money_saved,
        'cost_controls': cost_controls,
        'rosi': rosi,
        'dr_strategy': strategy,
        'notes': 'Generated by Streamlit prototype (app.py)'
    }

    try:
        pdf_bytes = generate_pdf_bytes(report_data)
        file_name = f"streamlit_report_{datetime.utcnow().strftime('%Y%m%dT%H%M%S')}.pdf"
        st.download_button(label='Download PDF', data=pdf_bytes, file_name=file_name, mime='application/pdf')
        st.success('PDF generated — use the Download button to save it locally.')
    except Exception as e:
        st.error(f'Failed to generate PDF: {e}')
